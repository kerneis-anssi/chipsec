<?xml version="1.0"?>
<configuration platform="Renoir">
<!--
XML configuration for Renoir based platforms

Reference: PPR for AMD Family 17h Model 18h B1. 55570-B1 Rev 3.16 - Apr 14, 2021.
-->

  <!-- #################################### -->
  <!--                                      -->
  <!-- Information                          -->
  <!--                                      -->
  <!-- #################################### -->
  <info family="core">
    <sku did="0x1630" name="Renoir" code="Renoir" longname="Renoir Root Complex" />
  </info>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Integrated devices                   -->
  <!--                                      -->
  <!-- #################################### -->
  <pci>
    <!-- Table 13: PCI Device ID Assignments. -->
    <!-- Bus A and B are programmable. Here, we assume A = 5 and B = 1. -->
    <device name="ROOT"           bus="0" dev="0x00"  fun="0" vid="0x1022" did="0x15D0" />
    <device name="IOMMU"          bus="0" dev="0x00"  fun="2" vid="0x1022" did="0x15D1" />
    <device name="HOSTDUMMY0"     bus="0" dev="0x01"  fun="0" vid="0x1022" did="0x1452" />
    <!-- PCIe GPP Bridge -->
    <device name="GPP0"           bus="0" dev="0x01"  fun="1" vid="0x1022" did="0x15D3" />
    <device name="GPP1"           bus="0" dev="0x01"  fun="2" vid="0x1022" did="0x15D3" />
    <device name="GPP2"           bus="0" dev="0x01"  fun="3" vid="0x1022" did="0x15D3" />
    <device name="GPP3"           bus="0" dev="0x01"  fun="4" vid="0x1022" did="0x15D3" />
    <device name="GPP4"           bus="0" dev="0x01"  fun="5" vid="0x1022" did="0x15D3" />
    <device name="GPP5"           bus="0" dev="0x01"  fun="6" vid="0x1022" did="0x15D3" />
    <device name="GPP6"           bus="0" dev="0x01"  fun="7" vid="0x1022" did="0x15D3" />
    <device name="HOSTDUMMY1"     bus="0" dev="0x08"  fun="0" vid="0x1022" did="0x1452" />
    <device name="GPP0TOBUSA"     bus="0" dev="0x08"  fun="1" vid="0x1022" did="0x15DB" />
    <device name="GPP0TOBUSB"     bus="0" dev="0x08"  fun="2" vid="0x1022" did="0x15DC" />
    <!-- Note: Vendor ID 1002h is used for Internal GPU and Display HD Audio Controller. -->
    <!-- Model 18h: did=0x15D8. Models 10h, 11h: did=0x15DD -->
    <device name="GPU"            bus="5" dev="0x00"  fun="0" vid="0x1002" did="0x15D8,0x15DD" />
    <device name="DISPLAYHDAUDIO" bus="5" dev="0x00"  fun="1" vid="0x1002" did="0x15DE" />
    <device name="USB0"           bus="5" dev="0x00"  fun="3" vid="0x1022" did="0x15E0" />
    <device name="USB1"           bus="5" dev="0x00"  fun="4" vid="0x1022" did="0x15E1" />
    <device name="AUDIO"          bus="5" dev="0x00"  fun="5" vid="0x1022" did="0x15E2" />
    <device name="HDAUDIO"        bus="5" dev="0x00"  fun="6" vid="0x1022" did="0x15E3" />
    <!-- Data Fabric devices -->
    <device name="DF0"            bus="0" dev="0x18" fun="0" vid="0x1022" did="0x15E8" />
    <device name="DF1"            bus="0" dev="0x18" fun="1" vid="0x1022" did="0x15E9" />
    <device name="DF2"            bus="0" dev="0x18" fun="2" vid="0x1022" did="0x15EA" />
    <device name="DF3"            bus="0" dev="0x18" fun="3" vid="0x1022" did="0x15EB" />
    <device name="DF4"            bus="0" dev="0x18" fun="4" vid="0x1022" did="0x15EC" />
    <device name="DF5"            bus="0" dev="0x18" fun="5" vid="0x1022" did="0x15ED" />
    <device name="DF6"            bus="0" dev="0x18" fun="6" vid="0x1022" did="0x15EE" />
    <!-- Not documented, but exists according to illumos developpers -->
    <device name="DF7"            bus="0" dev="0x18" fun="7" vid="0x1022" did="0x15EF" />
    <device name="SATAMS"         bus="1" dev="0x00"  fun="0" vid="0x1022" did="0x7901" />
    <device name="SATAAMD"        bus="1" dev="0x00"  fun="0" vid="0x1022" did="0x7904" />
    <device name="SD"             bus="0" dev="0x14" fun="6" vid="0x1022" did="0x7906" />
    <device name="SMBUS"          bus="0" dev="0x14" fun="0" vid="0x1022" did="0x790B" />
    <device name="LPC"            bus="0" dev="0x14" fun="3" vid="0x1022" did="0x790E" />
    <device name="SATARAID0"      bus="1" dev="0x00"  fun="0" vid="0x1022" did="0x7916" />
    <device name="SATARAID1"      bus="1" dev="0x00"  fun="0" vid="0x1022" did="0x7917" />
    <device name="GBE0"           bus="1" dev="0x00"  fun="1" vid="0x1022" did="0x1458" />
    <device name="GBE1"           bus="1" dev="0x00"  fun="2" vid="0x1022" did="0x1458" />
    <device name="FUNCTIONDUMMY"  bus="1" dev="0x00"  fun="0" vid="0x1022" did="0x145A" />
  </pci>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Memory Mapped I/O spaces (MMIO BARs) -->
  <!--                                      -->
  <!-- #################################### -->
  <mmio>
    <bar name="APIC_BAR" register="APIC_BAR" bus="0" base_field="ApicBar" size="0x1000" enable_field="ApicEn" desc="APIC Base Address"/>
    <bar name="IOMMUBAR" register="IOMMU_CAP_BASE_LO" base_field="IOMMU_BASE_ADDR_LO" register_high="IOMMU_CAP_BASE_HI"  base_field_high="IOMMU_BASE_ADDR_HI" enable_field="IOMMU_ENABLE" desc="" />
    <!-- The size of the MMIO configuration space is at least 1MB and depends on field BusRange. It is computed in mmio.py. -->
    <bar name="MMCFG" register="MmioCfgBaseAddr" bus="0" base_field="MmioCfgBaseAddr" enable_field="Enable" desc="MMIO Base Address"/>

    <!-- IOMMU section 8.1.2.3 defines a number of BARs which are not used
    to access registers but MMIO data structures. Defining them here is
    useful to simplify dumping the relevant parts of memory, even if they are
    referenced in the <register> section. -->
    <bar name="IOMMU_MMIO_DEVTBL_BASE" bus="0" register="IOMMU_MMIO_DEVTBL_BASE_0" base_field="DEV_TBL_BASE_LO" register_high="IOMMU_MMIO_DEVTBL_BASE_1" base_field_high="DEV_TBL_BASE_HI" desc="" />

    <bar name="SPIBAR" register="SPIBaseAddr" base_field="Spi_eSpi_BaseAddr" enable_field="SpiRomEnable" size="0xFF"   desc="SPI Controller Register Range" fixed_address="0xFEC10000" />
    <bar name="eSPIBAR" register="SPIBaseAddr" base_field="Spi_eSpi_BaseAddr" size="0xFF" fixed_address="0xFEC10000" offset="0x10000" desc="eSPI Controller Register Range" />
  </mmio>

  <!-- #################################### -->
  <!--                                      -->
  <!-- I/O spaces (I/O BARs)                -->
  <!--                                      -->
  <!-- #################################### -->
  <io>
  </io>

  <!-- #################################### -->
  <!--                                      -->
  <!-- SMN spaces (SMN BARs)                -->
  <!--                                      -->
  <!-- #################################### -->
  <smn>
    <bar name="SMUTHM" fixed_address="0x00059800" />
    <bar name="IOMMUL1INT0" fixed_address="0x14700000" desc="IOMMUL1 SMN Registers Base Address (PCIE0)" />
    <bar name="IOMMUL1INT1" fixed_address="0x14800000" desc="IOMMUL1 SMN Registers Base Address (IOAGR)" />
    <bar name="IOMMUL2A" fixed_address="0x15700000" desc="IOMMUL2 SMN Registers Base Address" />
  </smn>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Memory ranges                        -->
  <!--                                      -->
  <!-- #################################### -->
  <memory>
  </memory>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Configuration registers              -->
  <!--                                      -->
  <!-- #################################### -->
  <registers>
    <!-- PCIe Configuration (CFG) Registers -->

    <!-- 8.1.2.2 IOMMUL2 Registers -->
    <!-- Those registers are also accessible as SMN from BAR IOMMUCFG=0x13F00000 -->
    <register name="IOMMU_VENDOR_ID" type="pcicfg" device="IOMMU" offset="0x0" size="4">
      <field name="VENDOR_ID" bit="0" size="15" desc="Vendor Identifier." />
    </register>
    <register name="IOMMU_CAP_BASE_LO" type="pcicfg" device="IOMMU" offset="0x44" size="4">
      <field name="IOMMU_BASE_ADDR_LO" bit="19" size="12" desc="Low bits of the 512KB-aligned base address of the IOMMU memory-mapped control registers" />
      <field name="IOMMU_ENABLE" bit="0" size="1" desc="Enable IOMMU memory-mapped control registers" />
    </register>
    <register name="IOMMU_CAP_BASE_HI" type="pcicfg" device="IOMMU" offset="0x48" size="4">
      <field name="IOMMU_BASE_ADDR_HI" bit="0" size="32" desc="High bits of the 512KB-aligned base address of the IOMMU memory-mapped control registers" />
    </register>
    <!-- TODO: add other IOMMUL2 registers if necessary. -->

    <!-- 9.2.9.1 LPC Bridge Configuration Registers -->
    <register name="ROMAddrRng1" type="pcicfg" device="LPC" offset="0x68" size="4" desc="ROM Address Range 1">
      <field name="RomEndAddress1"  bit="16"  size="16" desc="ROM End Address 1"/>
      <field name="RomStartAddress1"  bit="0" size="16" desc="ROM Start Address 1"/>
    </register>
    <register name="ROMAddrRng2" type="pcicfg" device="LPC" offset="0x6C" size="4" desc="ROM Address Range 2">
      <field name="RomEndAddress2"  bit="16"  size="16" desc="ROM End Address 2"/>
      <field name="RomStartAddress2"  bit="0" size="16" desc="ROM Start Address 2"/>
    </register>
    <register name="SPIBaseAddr" type="pcicfg" device="LPC" offset="0xA0" size="4" desc="SPI base address">
      <field name="Spi_eSpi_BaseAddr"  bit="8" size="24" desc=""/>
      <field name="PspSpiMmioSel"  bit="4" size="1" desc=""/>
      <field name="RouteTpm2Spi"  bit="3" size="1" desc=""/>
      <field name="AbortEnable"  bit="2" size="1" desc=""/>
      <field name="SpiRomEnable"  bit="1" size="1" desc=""/>
      <field name="AltSpiCSEnable"  bit="0" size="1" desc=""/>
    </register>
    <!-- TODO: add other LPC registers if necessary. -->

    <!-- Memory-Mapped I/O (MMIO) Registers -->

    <!-- 2.1.11.2.2 Local APIC Registers -->
    <register name="ApicId" type="mmio" bar="APIC_BAR" offset="0x20" size="4" desc="APIC ID">
      <field name="ApicId" bit="24" size="8" desc="APIC ID"/>
    </register>
    <!-- TODO: add other APIC registers if necessary. -->

    <!-- 8.1.2.3 IOMMUMMIO Registers -->
    <!-- Those registers are also accessible as SMN from BAR IOMMUMMIO=0x02400000 -->
    <register name="IOMMU_MMIO_DEVTBL_BASE_0" type="mmio" bar="IOMMUBAR" offset="0x0" size="4" >
      <field name="DEV_TBL_BASE_LO" bit="12" size="20" desc="Low bits of 4K byte-aligned base address of the first level device table"/>
      <field name="DEV_TBL_SIZE" bit="0" size="9" desc="1 less than the length of the device table, in multiples of 4K bytes" />
    </register>
    <register name="IOMMU_MMIO_DEVTBL_BASE_1" type="mmio" bar="IOMMUBAR" offset="0x4" size="4" >
      <field name="DEV_TBL_BASE_HI" bit="0" size="20" desc="High bits of 4K byte-aligned base address of the first level device table"/>
    </register>
    <!-- TODO: add other IOMMUIO registers if necessary. -->

    <!-- 9.2.9.3.2 SPI registers -->
    <register name="SPI_Cntrl0" type="mmio" bar="SPIBAR" offset="0x00" size="4" desc="SPI_Cntrl0 Register">
      <field name="SPI_OpCode"         bit="0"  size="8" desc="When software uses the alternate program method to communicate with the SPI ROM, this register contains the OPCODE"/>
      <field name="TxByteCount"        bit="8"  size="4" desc="Number of bytes to be sent to SPI ROM"/>
      <field name="RxByteCount"        bit="12" size="4" desc="Number of bytes to be received from the SPI ROM"/>
      <field name="ExecuteOpCode"      bit="16" size="1" desc="Write 1 to execute the transaction in the alternate program registers. Write 0 has no effect. When the transaction is complete, this bit will return 0. If the command is an illegal command, the bit cannot be set and thereby cannot execute"/>
      <field name="Reserved"           bit="17" size="2" desc=""/>
      <field name="SpiArbEnable"       bit="19" size="1" desc="If a MAC is sharing the ROM with the SB, both chips will need to go through an arbitration process before either one can
access the ROM. This bit enables the arbitration. If MAC is not sharing the SPI ROM, BIOS should set this bit to 0 to speed up the SPI ROM access"/>
      <field name="FifoPtrClr"         bit="20" size="1" desc="(write only) A write of 1 to this bit will clear the internal FIFO pointer"/>
      <field name="FifoPtrInc"         bit="21" size="1" desc="(write only ) A write of 1 to this bit will cause the internal FIFO pointer to be incremented by 1"/>
      <field name="SpiAccessMacRomEn"  bit="22" size="1" desc="This is a clear-once protection bit; once set, software cannot access MAC’s portion of the ROM space (lower 512KB)."/>
      <field name="SpiHostAccessRomEn" bit="23" size="1" desc="This is a clear-once protection bit; once set, MAC cannot access BIOS ROM space (upper 512KB)"/>
      <field name="ArbWaitCount"       bit="24" size="3" desc="Under ROM sharing mode (with the MAC) this defines the amount of wait time this controller will assert HOLD# before it should access the SPI ROM. This time is to allow the MAC to sample HOLD#."/>
      <field name="SpiBridgeDisable"   bit="27" size="1" desc="Setting this bit will disable the SPI bridge mode (SB600 will act as a SPI-LPC bridge to the MAC)"/>
      <field name="Reserved"           bit="28" size="4" desc=""/>
    </register>
    <register name="SPI_RestrictedCmd1" type="mmio" bar="SPIBAR" offset="0x04" size="4" desc="SPI_RestrictedCmd1 Register">
      <field name="RestrictedCmd0" bit="0"  size="8" desc="This defines a restricted command issued by the MAC which will be checked by the SB600. If the opcode issued by the MAC matches with this register and the address space is in the BIOS space, this controller will simply ignore the command for the case of bridge mode. For peer mode, the SPI controller will jam the entire interface as an attempt to stop that transaction. Note either SpiAccessMacRomEn and/or SpiHostAccessRomEn bit is cleared, these registers become read only and cannot be changed any more."/>
      <field name="RestrictedCmd1" bit="8"  size="8" desc="Same as RestrictedCmd0"/>
      <field name="RestrictedCmd2" bit="16" size="8" desc="Same as RestrictedCmd0"/>
      <field name="RestrictedCmd3" bit="24" size="8" desc="Same as RestrictedCmd0"/>
    </register>
    <register name="SPI_RestrictedCmd2" type="mmio" bar="SPIBAR" offset="0x08" size="4" desc="SPI_RestrictedCmd1 Register">
      <field name="RestrictedCmd4"       bit="0"  size="8" desc="Same as RestrictedCmd0"/>
      <field name="RestrictedCmdWoAddr0" bit="8"  size="8" desc="Same as RestrictedCmd0 except this command does not have address"/>
      <field name="RestrictedCmdWoAddr1" bit="16" size="8" desc="Same as RestrictedCmd0 except this command does not have address"/>
      <field name="RestrictedCmdWoAddr2" bit="24" size="8" desc="Same as RestrictedCmd0 except this command does not have address"/>
    </register>
    <register name="SPI_Cntrl1" type="mmio" bar="SPIBAR" offset="0x0C" size="4" desc="SPI_Cntrl1 Register">
      <field name="SPIParameters"   bit="0" size="8" desc="This is the TX/RX FIFO port which can take up to 8 bytes. To send data to SPI ROM, software writes data into this port. To retrieve data that are received from the SPI ROM, software reads from this port."/>
      <field name="FifoPtr"         bit="8" size="3" desc="This three bits show the internal pointer location"/>
      <field name="TrackMacLockEn"  bit="11" size="1" desc="When set, the controller will lock the SPI for the MAC when it has detected a command (from the MAC) matching the value defined in offset 10h or 11h. Conversely, it will unlock the bus when it has detected a command (from the MAC) matching the value defined in offset 12h or 13h"/>
      <field name="NormSpeed"       bit="12" size="2" desc="This defines the clock speed for the non-fast read command. 00 – Reserved, 01 – 33Mhz, 10 – 22 Mhz, 11 – 16.5Mhz"/>
      <field name="FastSpeed"       bit="14" size="2" desc="This defines the clock speed for the fast speed read. 00 – Reserved, 01 – 33Mhz, 10 – 22 Mhz, 11 – 16.5Mhz"/>
      <field name="WaitClkInterval" bit="16" size="6" desc="Timing parameters used for SPI sharing protocol"/>
      <field name="SetLockCmd"      bit="22" size="1" desc="Lock the SPI bus on the next transaction"/>
      <field name="SetUnlockCmd"    bit="23" size="1" desc="Unlock the SPI bus on the next transaction"/>
      <field name="ByteProgramCmd"  bit="24" size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the BYTE PROGRAM command."/>
    </register>
    <register name="SPI_CmdValue0" type="mmio" bar="SPIBAR" offset="0x10" size="4" desc="SPI_CmdValue0 Register">
      <field name="MacLockCmd0"   bit="0"  size="8" desc="This is used to compare against the opcode sent out by the MAC. If SPI_Cntrl1[11] is set, the controller will lock the SPI bus for the MAC. In other words, the MAC has the exclusive access to the ROM; access by the CPU will be delayed until this is unlocked. This is to allow the MAC to do certain sequence of operations without interruption."/>
      <field name="MacLockCmd1"   bit="8"  size="8" desc="Same as MacLockCmd0"/>
      <field name="MacUnlockCmd0" bit="16" size="8" desc="This is used to compare against the opcode sent out by the MAC. If SPI_Cntrl1[11] is set, the controller will unlock the SPI bus for the MAC. In other words, access by the CPU will be allowed again."/>
      <field name="MacUnlockCmd1" bit="24" size="8" desc="Same as MacUnlockCmd0"/>
    </register>
    <register name="SPI_CmdValue1" type="mmio" bar="SPIBAR" offset="0x14" size="4" desc="SPI_CmdValue1 Register">
      <field name="WREN" bit="0"  size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the WREN (write enable) command from the MAC. In the bridge mode, SB600 will need to decode commands from the MAC"/>
      <field name="WRDI" bit="8"  size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the WRDI (write disable) command from the MAC."/>
      <field name="RDID" bit="16" size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the RDID (read ID) command from the MAC"/>
      <field name="RDSR" bit="24" size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the RDSR (read status register) command from the MAC"/>
    </register>
    <register name="SPI_CmdValue2" type="mmio" bar="SPIBAR" offset="0x18" size="4" desc="SPI_CmdValue2 Register">
      <field name="Read"   bit="0"  size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the Read (Read byte) command from the MAC. In the bridge mode, SB600 will need to decode commands from the MAC"/>
      <field name="FRead"  bit="8"  size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the FRead (fast read) command from the MAC."/>
      <field name="PAGEWR" bit="16" size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the PAGEWR (page write) command from the MAC"/>
      <field name="BYTEWR" bit="24" size="8" desc="This is used to compare against the opcode sent out by the MAC. This is a predefined value to decode for the BYTEWR (byte write) command from the MAC."/>
    </register>
    <register name="SPI_FakeID" type="mmio" bar="SPIBAR" offset="0x1C" size="1" desc="SPI_FakeID Register">
      <field name="SPI_FakeID" bit="0" size="8" desc="This is used as the faked ID value to be returned to the MAC as a response to the RDID command. This is only used under the bridge mode."/>
    </register>

    <!-- 9.2.9.4 eSPI registers -->
    <register name="DN_TXHDR_0th" type="mmio" bar="eSPIBAR" offset="0x00" size="4" desc="Hardware Sequencing Flash Control Register">
      <field name="DNCMD_HDATA2" bit="24"  size="8" desc=""/>
      <!-- more fields  ... -->
    </register>
    <!-- TODO: add other SPI registers if necessary. -->

    <!-- System Management Network (SMN) Registers -->

    <!-- 4.2.1 Thermal Registers -->
    <register name="THM_TCON_CUR_TMP" type="smn" bar="SMUTHM" device="DF0" offset="0x0">
      <field name="CUR_TEMP" bit="21" size="11" />
      <field name="CUR_TEMP_RANGE_SEL" bit="19" size="1" />
    </register>

    <!-- 8.1.2.1 IOMMUL1 Registers -->
    <register name="L1_MISC_CNTRL_1_PCIE0" type="smn" bar="IOMMUL1INT0" device="DF0" offset="0x1C">
      <field name="REG_enable_nw"  bit="17"  size="1" />
      <field name="REG_force_invalid_filter"  bit="6"  size="1" />
      <field name="REG_force_OrderStreamID_func"  bit="0"  size="1" />
    </register>
    <register name="L1_MISC_CNTRL_1_IOAGR" type="smn" bar="IOMMUL1INT1" device="DF0" offset="0x1C">
      <field name="REG_enable_nw"  bit="17"  size="1" />
      <field name="REG_force_invalid_filter"  bit="6"  size="1" />
      <field name="REG_force_OrderStreamID_func"  bit="0"  size="1" />
    </register>
    <!-- TODO: add other IOMMUL1 registers if necessary. -->
    <!-- 8.1.2.2 IOMMUL2 Registers -->
    <register name="L2A_UPDATE_FILTER_CNTL" type="smn" bar="IOMMUL2A" device="DF0" offset="0x88">
      <field name="L2a_Update_Filter_Bypass"  bit="0"  size="1" />
    </register>
    <!-- TODO: add other IOMMUL2 registers if necessary. -->


    <!-- Port I/O Registers -->

    <!-- 2.1.7 PCI Configuration Legacy Access -->
    <register name="IoCfgAddr" type="io" port="0xCF8" size="4" desc="IO-Space Configuration Address">
      <field name="ConfigEn" bit="31"  size="1"  desc="Configuration space enable"/>
      <field name="ExtRegNo" bit="24"  size="4"  desc="Extended register number"/>
      <field name="BusNo" bit="16"  size="8"  desc="Bus number"/>
      <field name="Device" bit="11"  size="5"  desc="Device number"/>
      <field name="Function" bit="8"  size="3"  desc="Function"/>
      <field name="RegNo" bit="2"  size="6"  desc="Register address"/>
    </register>
    <register name="IoCfgData" type="io" port="0xCFC" size="4" desc="IO-Space Configuration Data Port">
      <field name="Data" bit="0"  size="32"  desc="Data"/>
    </register>

    <!-- 9.2.1 Legacy Block Configuration Registers (IO): not included -->


    <!-- CPU Model Specific Registers (MSR) -->

    <!-- 2.1.13.1 MSRs - MSR0000_xxxx-->
    <register name="TSC"  type="msr" msr="0x10" desc="Time Stamp Counter">
      <field name="TSC" bit="0" size="64" desc="Time stamp counter" />
    </register>
    <register name="APIC_BAR" type="msr" msr="0x1B" desc="APIC Base Address">
      <field name="ApicBar" bit="12" size="36" desc="APIC base address register" />
      <field name="ApicEn" bit="11" size="1" desc="APIC enable" />
      <field name="BSC" bit="8" size="1" desc="Boot strap core" />
    </register>
    <!-- TODO: add other MSR registers if necessary. -->
    <!-- 2.1.13.2 MSRs - MSRC000_0xxx-->
    <!-- 2.1.13.3 MSRs - MSRC001_0xxx-->
    <register name="MmioCfgBaseAddr" type="msr" msr="0xC0010058" desc="MMIO Base Address">
      <field name="MmioCfgBaseAddr" bit="20" size="28" desc="MMIO configuration base address" />
      <field name="BusRange" bit="2" size="4" desc="Bus range identifier" />
      <field name="Enable" bit="0" size="1" desc="Enable bit" />
    </register>
    <!-- 2.1.13.4 MSRs - MSRC001_1xxx-->
    <!-- 3.2.5 MCA Banks -->

  </registers>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Controls                             -->
  <!--                                      -->
  <!-- #################################### -->
  <controls>
  </controls>

  <!-- #################################### -->
  <!--                                      -->
  <!-- Locks                                -->
  <!--                                      -->
  <!-- #################################### -->
  <locks>
  </locks>

</configuration>
